JS引擎会常驻内存中，等待我们把JS在特定时机给他执行

#### 宏观和微观任务
我们的事件通常都是不断重复等待-执行的过程。那在我们每次执行的过程中，就相当于是一个宏观任务。但因为在宏观任务中，我们还会有一些异步代码，js必须保证这些异步代码在一个宏观任务里面完成，因此每个宏观任务里还会包含一个微观任务队列。
+ Promise 需要进行等待的函数，先不返回真实结果，而返回一个承诺，并在合适的时间里等待这个承诺实现

异步执行顺序：多少宏任务-宏任务中多少微任务-确定宏任务中微任务执行次序-宏任务执行次序

宏任务有I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame

##### 手动实现Promise

##### 实现异步函数

#### 闭包
 闭包区别于非纯函数，他携带了执行的环境到函数内。那就是说我们用到全局变量的函数，其实在闭包的定义上来说也是。

#### 执行上下文
执行所需的所有信息定义。
lexical environment：词法环境，当获取变量或者 this 值时使用。
variable environment：变量环境，当声明变量时使用。
code evaluation state：用于恢复代码执行位置。
Function：执行的任务是函数时使用，表示正在被执行的函数。
ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
Realm：使用的基础库和内置对象实例。
Generator：仅生成器上下文有这个属性，表示当前生成器。

##### 立即执行函数表达式IIFE
通过创建一个函数来构造一个新的御宠，而控制var的范围。那通常我们的做法就是在这上面加括号。因为如果上一行不写分号，括号会被解释为上一行代码最末的函数调用。可以用void function(){}()避免，表示忽略后面表达式的值

##### let
使得块级作用域正式生效 if for switch

##### realm
什么都一样，但是他就是两个不一样的JS环境。

##### this
普通函数的 this 值由“调用它所使用的引用”决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 Reference 类型（记得我们在类型一章讲过七种标准类型吗，正是其中之一）。
Reference 类型由两部分组成：一个对象和一个属性值。不难理解 o.showThis 产生的 Reference 类型，即由对象 o 和属性“showThis”构成

当做一些算术运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象

###### 箭头函数为啥this值指向不一致
箭头函数总是指向所在函数运行时的this

##### 操纵this
Function.prototype.call 和 Function.prototype.apply 和 Function.prototype.bind
call apply bind 手写